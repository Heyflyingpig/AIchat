<!-- static/index.html -->
<!DOCTYPE html>
<html>
<head>
    <style>
    /* 这里需要注意几点：
    1. 空格: 在 CSS 选择器中，空格表示"后代"关系。
    它意味着后面的元素是前面元素的子元素、孙子元素或更深层级的后代元素。
    2. 而.sidebar.active: 这部分选中同时拥有 sidebar 类和 active 类的同一个 HTML 元素。*/
    /* 新增侧边栏样式 
    */
    .sidebar {
        position: fixed;   /* 固定位置（相对于浏览器）*/
        left: -300px; /* 位于左边缘的-300位置。*/
        top: 0;  /* 贴紧顶部*/
        width: 300px;
        height: 100vh;  /* 相对高度*/
        background: white;
        box-shadow: 2px 0 5px rgba(0,0,0,0.1); /* rgba(0,0,0,0.1)` 是阴影的颜色。`rgb(0,0,0)` 
                                                    是黑色，`a(0.1)` 表示透明度为 10%。*/
        transition: left 0.3s; /* 设置过渡效果。当 `left` 属性的值发生变化时*/
        z-index: 1000; /* 堆叠窗格的大小*/
        display: flex; /* `display: flex` 启用 Flexbox 布局模型。便于该元素的子元素可以更容易地进行排列和对齐。*/
        flex-direction: column; /* 在 Flexbox 布局下，设置主轴的方向为垂直方向。
        这意味着侧边栏内部的直接子元素（header, content, footer）会从上到下垂直排列。*/
        overflow: hidden; /* 防止超出范围*/
    }
    .sidebar.active { /* 这是sidebar的active组合类*/
        left: 0; /* 将侧边栏的左边缘设置在浏览器窗口的左边缘，即 `0` 的位置。
        配合上面的 `transition`，这会使侧边栏从左侧平滑滑入视图。*/
    }
    .sidebar-header {   
        padding: 15px; /* 设置元素内容与其边框之间的内边距。`15px` 表示上下左右都有 15 像素的内边距。*/
        display: flex;
        align-items: center; /* 在 Flexbox 的交叉轴，也就是竖向的交叉方向。*/
        border-bottom: 1px solid #eee; /* 给元素的底部添加一条边框。
                                          `1px` 是边框的宽度。
                                          `solid` 是边框的样式（实线）*/
        justify-content: space-between; /* 在 Flexbox 的主轴（这里是水平方向）上对齐子元素。
                                           `space-between` 表示子元素沿主轴均匀分布*/
    }
    .sidebar-content {
        flex: 1; /* 这是 Flexbox 布局中的一个缩写属性。`flex: 1` 通常表示 
                    它表示该元素将占据父容器（`.sidebar`）在主轴（垂直方向）上的所有可用剩余空间。*/
        overflow-y: auto; /* 增加滚动条 */
        padding: 15px;
    }
    
    .history-item {
        padding: 12px;
        margin: 8px 0; /* 设置外边距。分别是上下，左右*/
        border: 1px solid #eee; /* 设置边框。*/
        cursor: pointer; /* 当鼠标悬停在该元素上时，显示小手形状的光标，提示用户这个元素是可以点击的。*/
        border-radius: 5px; /* 半径：圆角*/
        display: flex; /* 启用 Flexbox 布局，用于排列条目内部的会话信息和预览文本。*/
        justify-content: space-between;
        align-items: center; /* 交叉方向垂直排列。*/
    }
    .sidebar-footer {
        padding: 15px;
        border-top: 1px solid #eee;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .sidebar-toggle {
        cursor: pointer;
        font-size: 24px;
        padding: 5px;
        display: none;
    }
    .sidebar.active .sidebar-toggle {
        display: block; /* 当侧边栏处于激活（可见）状态时，将这个关闭图标显示出来。*/
    }
    .menu-icon {
        position: fixed;
        left: 5px;
        top: 10px;
        cursor: pointer;
        z-index: 1001;
        font-size: 24px; /* 图标大小*/
        padding: 5px; /* 给图标本身增加一点内边距，扩大可点击区域。*/
        display: block; /* `block` 元素会占据其父元素的整个宽度，并换行。这里确保图标作为一个块级元素存在。。
                           初始状态下，这个图标是可见的。*/
    }
    /* 3.通过检查 <body> 是否有 sidebar-active 类，就可以方便地控制页面上任何位置的 .menu-icon 的显示状态了。
        这是一种常用的通过给 body 添加类来管理全局页面状态的方法。 */
    body.sidebar-active .menu-icon {
        display: none; /* 将图标隐藏起来。当侧边栏打开时，就不需要显示这个用于打开侧边栏的图标了。*/
    }
    .container {
        margin-left: 0;
        transition: margin-left 0.3s; /* 当 `margin-left` 属性变化时，
        在 0.3 秒内平滑过渡。这使得主内容区在侧边栏打开/关闭时能平滑地移动。*/
        height: 100vh;
        display: flex;
        flex-direction: column;
    }
    .container.sidebar-active {
        margin-left: 300px; /* 随侧边栏移动*/
    }
    .chat-area {
        flex: 1;
        overflow-y: auto; 
        padding: 20px;
        transition: margin-left 0.3s; 
        display: flex;
        flex-direction: column;
        gap: 20px; /* `gap` 属性设置 Flexbox 或 Grid 布局中项目之间的间隙。
                        这里表示每条聊天消息之间有 10 像素的垂直间距。*/
    }
    .session-info {
        font-size: 0.9em;  /* 设置字体大小。`em` 是一个相对单位，`0.9em` 表示字体大小是其父元素字体大小的 90%。*/
        color: #666;
    }
    .input-area {
        position: sticky;/* 元素在跨越特定阈值前为相对定位，之后为固定定位。
                            配合下面的 `bottom: 0`，这意味着当用户向上滚动页面时，这个输入区域会像普通内容一样滚动，
                            但当它滚动到视口底部时，就会"粘"在那里，不再向上滚动，始终保持在屏幕底部可见。*/
        bottom: 0;
        background: white;
        padding: 15px 20px;
        box-shadow: 0 -2px 10px rgba(0,0,0,0.05); /* 添加阴影效果。
                                                     `0` 水平偏移。
                                                     `-2px` 垂直偏移（向上）。
                                                     `10px` 模糊半径。
                                                     `rgba(0,0,0,0.05)` 颜色（非常淡的黑色）。
                                                     这个阴影出现在输入区域的上方，将其与聊天区分开。*/
        display: flex;
        align-items: center;
        gap: 10px; 
    }

    /* 让输入框占据剩余空间 */
    #messageInput { /* 选中 ID 为 `messageInput` 的元素（文本输入框）。ID 选择器用 `#` 开头。*/
        flex: 1;
        border: 1px solid #ccc;
        border-radius: 5px;
        padding: 10px;
        font-size: 1em;
        resize: none;  /* `resize` 属性允许用户调整元素的尺寸。`none` 表示禁止用户调整 `textarea` 的大小。*/
    }

    /* 发送按钮样式 */
    .input-area button {
        padding: 10px 15px;
        border: none;  /* 移除按钮的默认边框。*/
        background-color: #007bff;
        color: white;
        border-radius: 5px;
        cursor: pointer;
        font-size: 1em;
    }
    .input-area button:hover {
        background-color: #0056b3; /* 这是一个伪类选择器。它选中当鼠标悬停在按钮上时的状态。*/
    }

    .message {
        max-width: 80%;
        padding: 10px 15px;
        border-radius: 10px;
        word-break: break-word;  /* `word-break` 属性规定自动换行的处理方法。
                    将在任意字符处被强制换行，以防止文本溢出。*/
        line-height: 1.4;
    }

    /* 用户消息样式 */
    .user-message {
        background-color: #dcf8c6;
        align-self: flex-end; /* 用户消息靠右 */
    }

    /* AI 消息样式 */
    .ai-message {
        background-color: #f1f0f0;
        align-self: flex-start; /* AI 消息靠左 */
        margin-left: 10px; /* 新增：为左侧菜单图标留出空间 */
    }
    
    .preview-text {
        font-size: 0.9em; /* 设置你想要的字体大小，例如 12px 或 0.8em */
        color: #454545;
        font-weight: bold;    
        
    }
    .session-time {
        font-size: 0.8em;
        color: #888;
    }
    </style>
</head>
<body>
    <!-- 侧边栏图标 -->
    <div class="menu-icon" onclick="toggleSidebar()">☰</div>

    <!-- 侧边栏 -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <h3>FLYINGPIG-AI</h3>
            <div class="sidebar-toggle" onclick="toggleSidebar()">☰</div>
        </div>
        
        <div class="sidebar-content">
            <!-- 这个 div 使用了 `style` 属性来直接设置内联样式。这通常用于特定、小范围或动态的样式设置。 -->
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <select id="apiSelect" style="flex:1;">
                    <option value="zhipuai">质谱AI</option>
                    <option value="aliyunai">阿里云AI</option>
                    <option value="deepseek">Deepseek</option>
                </select>
                <button onclick="newChat()">新建</button>
            </div>
            
            <div id="historyList">
                <div class="history-item" style="display: none;">
                     <!-- style="display: none;": 内联样式，使这个模板默认不显示。JavaScript 加载真实数据时会创建新的、可见的 history-item。 -->
                    <div class="session-info">
                        <div class="session-time"></div>
                    </div>
                    <div class="preview-text"></div>
            </div>
        </div>
    </div> <!-- sidebar-content 的结束标签 -->
        
        <div class="sidebar-footer">
            <button>设置</button>
            <div style="width: 40px; height: 40px; border-radius: 50%; background: #eee;"></div>
        </div>
    </div>

    
    <div class="container" id="mainContainer">
        
        <div class="chat-area" id="chatArea"></div>
        <!-- class="chat-area": 用于样式化聊天消息区域。 -->
        <div class="input-area">
            <textarea id="messageInput" placeholder="输入消息..." rows = "3"></textarea>
            <button onclick="sendMessage()">发送</button>
        </div>
    </div>

    <script>
        // 初始化
        document.getElementById('messageInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // API交互，使用异步调用，防止页面阻塞
        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim(); 
            // `input.value` 获取输入框中当前的文本内容。`.trim()` 移除字符串两端的空白字符（空格、换行符等）。
            if (!message) return;

            addMessage(message, 'user');
            input.value = '';//清空输入框内容。

            try {
                const response = await fetch('/api/send', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},//设置请求头为 JSON 格式
                    body: JSON.stringify({ message })  // `body` 是请求体，包含要发送的数据。
                });
                
                const data = await response.json();
                if (data.success) {
                    addMessage(data.response, 'ai');
                } else {
                    showError(data.error);
                }
            } catch (error) {
                showError('错误'+ error);
            }
        }

        // 界面更新
        function addMessage(text, sender) {
            const chatArea = document.getElementById('chatArea'); // 获取聊天区域
            const div = document.createElement('div');
            div.className = `message ${sender}-message`; // 类名保持不变
             // 它会包含 'message' 类和根据发送者是 'user' 还是 'ai' 动态添加的 'user-message' 或 'ai-message' 类。这对应了 CSS 中的样式规则。
            div.textContent = text;
            chatArea.appendChild(div);
            // 修改滚动逻辑，滚动聊天区域而不是整个 body
            chatArea.scrollTop = chatArea.scrollHeight; 
            // `chatArea.scrollHeight` 是 `chatArea` 内部内容的总高度（即使内容超出了可见区域）。
             // `chatArea.scrollTop` 是 `chatArea` 向上滚动的距离。将其设置为 `scrollHeight` 意味着滚动到最底部，使用户能看到最新的消息。
            
        }

        function showError(msg) {
            alert('错误: ' + msg);
        }
        
        //清空所有记录
        function newChat() {
            if (confirm("确定要清空当前对话吗？")) {
                fetch('/api/new_chat', { method: 'POST' })
                    .then(response => response.json())// 解析响应为 JSON
                    .then(data => {
                        if (data.success) {
                            document.getElementById('chatArea').innerHTML = '';
                            console.log("新会话已创建，正在重新加载历史记录..."); // 添加日志
                            loadHistory(); // 清空聊天区域
                        }
                        else{
                            showError(data.error);
                        }
                    });
            }
        }
        // 设置控制，api选择
        document.getElementById('apiSelect').addEventListener('change', async (e) => {
            await fetch('/api/switch', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ api: e.target.value })// `e.target` 指向触发事件的元素（即 `select` 元素）。
                                                               // `e.target.value` 获取当前选中 `<option>` 的 `value` 属性值。
                                                               // 将选中的 API 值发送给后端。`await` 等待请求完成。
            });
        });
        /*
        // 温度选择
        document.getElementById('tempInput').addEventListener('change', async (e) => {
            await fetch('/api/temperature', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ temp: e.target.value })
            });
        });
        
        */
        // 新增侧边栏切换功能
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const main = document.getElementById('mainContainer');
            const body = document.body; // 获取 body 元素

            sidebar.classList.toggle('active');
                                                // 如果元素当前有 'active' 类，它会移除这个类；如果没有，它会添加这个类。
                                                // 这就实现了添加/移除 'active' 类的切换效果，从而触发 CSS 中 `.sidebar.active` 的样式规则（改变 `left` 值实现滑入滑出）。
            main.classList.toggle('sidebar-active');
            body.classList.toggle('sidebar-active'); // 在 body 上也切换类
        }

        // 修改加载历史功能
        function loadHistory() {
            fetch('/api/sessions')
                .then(response => response.json()) //必须解析
                .then(data => {
                    const historyList = document.getElementById('historyList');
                    historyList.innerHTML = ''; // 清空historylist，防止重复加载
                    
                    if (data.length === 0) {
                         console.warn("没有历史记录条目可供显示。");
                         historyList.innerHTML = '<p style="padding: 10px; color: #888;">没有历史会话记录。</p>';
                    }
                    data.forEach(([sessionId, sessionData]) => {
                        const item = document.createElement('div');
                        item.className = 'history-item';// 设置类名，应用 CSS 样式。
                        // 使用模板字面量设置 `innerHTML` 来快速构建条目的内部结构。
                        // <div class="session-id">${sessionId.slice(0, 8)}...</div>
                        item.innerHTML = `
                            <div class="session-info">
                                <div class="session-time">${new Date(sessionData.last_time).toLocaleString()}</div>
                            </div>
                            <div class="preview-text">${sessionData.preview}</div>
                        `;
                        item.onclick = () => loadSession(sessionId);
                        historyList.appendChild(item);
                    });
                });
}
// 当整个 HTML 文档的初始内容被完全加载和解析后，会触发 'DOMContentLoaded' 事件。
// 这通常是执行需要操作 DOM 的 JavaScript 代码的安全时机。
document.addEventListener('DOMContentLoaded', loadHistory);

        async function loadSession(sessionId) {
            console.log(`尝试加载会话: ${sessionId}`); // 添加日志，方便调试
            try {
                const response = await fetch(`/api/load_session?session=${sessionId}`);
                const data = await response.json();

                if (data.success) {
                    const chatArea = document.getElementById('chatArea');
                    chatArea.innerHTML = ''; // 清空当前聊天区域

                    // 遍历返回的消息并添加到聊天区
                    data.messages.forEach(message => {
                        addMessage(message.text, message.sender);
                    });

                    // 确保滚动到底部
                    chatArea.scrollTop = chatArea.scrollHeight;
                    // （可选）加载成功后关闭侧边栏
                    toggleSidebar(); 
                    console.log(`会话 ${sessionId} 加载成功`);
                } else {
                    showError(data.error); // 显示错误信息
                }
            } catch (error) {
                showError('加载会话时发生网络错误: ' + error); // 显示网络错误
                console.error("加载会话错误:", error);
            }
        }
    </script>
</body>
</html>